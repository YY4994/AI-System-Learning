# 矩阵乘法平铺索引详细图解

## 一、整体概念回顾

我们正在计算：**C = A × B**，其中：

- 每个线程计算C的一个元素
- 使用平铺技术将计算分解为多个阶段
- 每个阶段加载A和B的一个平铺到共享内存

## 二、索引计算详细解析

### 2.1 线程组织关系图

```
网格Grid结构：
┌─────────────────────────────────────────────┐
│         Grid (N/TILE_WIDTH × N/TILE_WIDTH)  │
│  ┌───────┬───────┬───────┬───────┐          │
│  │Block  │Block  │Block  │ ...   │          │
│  │ (0,0) │ (0,1) │ (0,2) │       │          │
│  ├───────┼───────┼───────┼───────┤          │
│  │Block  │Block  │Block  │ ...   │          │
│  │ (1,0) │ (1,1) │ (1,2) │       │          │
│  └───────┴───────┴───────┴───────┘          │
└─────────────────────────────────────────────┘

每个Block内部（TILE_WIDTH×TILE_WIDTH个线程）：
┌─────────────────────────────────┐
│  Block内部线程组织 (TILE_WIDTH=4)│
│  ┌───┬───┬───┬───┐              │
│  │(0,0)│(0,1)│(0,2)│(0,3)│ tx方向  │
│  ├───┼───┼───┼───┤              │
│  │(1,0)│(1,1)│(1,2)│(1,3)│       │
│  ├───┼───┼───┼───┤              │
│  │(2,0)│(2,1)│(2,2)│(2,3)│       │
│  ├───┼───┼───┼───┤              │
│  │(3,0)│(3,1)│(3,2)│(3,3)│ ty方向  │
│  └───┴───┴───┴───┘              │
└─────────────────────────────────┘
```

### 2.2 输出元素位置计算

```
// 计算当前线程负责的C元素位置
row = by * TILE_WIDTH + ty;  // C的行索引
col = bx * TILE_WIDTH + tx;  // C的列索引

示例：假设TILE_WIDTH=4，线程在Block(1,2)内，tx=1, ty=2
row = 2 * 4 + 2 = 10  // C的第10行
col = 1 * 4 + 1 = 5   // C的第5列
这个线程负责计算 C[10][5]
```

## 三、A矩阵索引详细图解

### 3.1 A矩阵的访问模式

```
矩阵乘法公式：C[i][j] = Σ A[i][k] × B[k][j]
对于固定行i（当前线程的row），需要访问A的整行

A矩阵结构：
列方向 →
┌─────────────────────────────────────┐
行│ A[0][0]  A[0][1]  ...  A[0][N-1]   │
↓│ A[1][0]  A[1][1]  ...  A[1][N-1]   │
 │    ...       ...    ...     ...     │
 │ A[i][0]  A[i][1]  ...  A[i][N-1]   │ ← 当前线程需要这一整行
 │    ...       ...    ...     ...     │
 │ A[N-1][0] A[N-1][1] ... A[N-1][N-1]│
└─────────────────────────────────────┘
```

### 3.2 平铺分解后A的访问

```
A矩阵被水平分割为平铺：
┌─────────────────────────────────────────┐
│ A矩阵：行i固定，列按平铺分割              │
│                                           │
│ 阶段t=0      阶段t=1      阶段t=2        │
│ ┌─────────┐ ┌─────────┐ ┌─────────┐     │
│ │ Tile₀   │ │ Tile₁   │ │ Tile₂   │ ... │
│ │ A[i][0:3]│ │ A[i][4:7]│ │ A[i][8:11]│ │
│ └─────────┘ └─────────┘ └─────────┘     │
└─────────────────────────────────────────┘
```

### 3.3 A的索引计算

```cpp
int A_col_index = t * TILE_WIDTH + tx;
int A_row_index = row;
```

**图解说明**：

```
对于阶段t，线程需要加载A的哪个元素？
1. 行索引：row（固定，因为计算C[row][col]需要A的row行）
2. 列索引：平铺起始列 + 线程在x方向的位置

A矩阵访问模式（TILE_WIDTH=4）：
阶段t=0: 加载列 0-3
  thread tx=0 → A[row][0]
  thread tx=1 → A[row][1]
  thread tx=2 → A[row][2]
  thread tx=3 → A[row][3]

阶段t=1: 加载列 4-7
  thread tx=0 → A[row][4]
  thread tx=1 → A[row][5]
  thread tx=2 → A[row][6]
  thread tx=3 → A[row][7]

通用公式：A_col_index = t×TILE_WIDTH + tx
```

## 四、B矩阵索引详细图解

### 4.1 B矩阵的访问模式

```
对于固定列j（当前线程的col），需要访问B的整列

B矩阵结构：
列方向 →
┌─────────────────────────────────────┐
行│ B[0][0]  B[0][1]  ...  B[0][j] ...│
↓│ B[1][0]  B[1][1]  ...  B[1][j] ...│
 │    ...       ...    ...     ...    │
 │ B[k][0]  B[k][1]  ...  B[k][j] ...│
 │    ...       ...    ...     ...    │
 │ B[N-1][0] B[N-1][1] ... B[N-1][j] │ ← 当前线程需要j列的所有行
└─────────────────────────────────────┘
```

### 4.2 平铺分解后B的访问

```
B矩阵被垂直分割为平铺：
┌─────────────────────────────────────────┐
│ B矩阵：列j固定，行按平铺分割              │
│                                           │
│       阶段t=0                            │
│       ┌─────────┐                        │
│       │ B[0][j] │                        │
│       │ B[1][j] │                        │
│       │ B[2][j] │                        │
│       │ B[3][j] │                        │
│       └─────────┘                        │
│                                           │
│       阶段t=1                            │
│       ┌─────────┐                        │
│       │ B[4][j] │                        │
│       │ B[5][j] │                        │
│       │ B[6][j] │                        │
│       │ B[7][j] │                        │
│       └─────────┘                        │
└─────────────────────────────────────────┘
```

### 4.3 B的索引计算

```cpp
int B_row_index = t * TILE_WIDTH + ty;
int B_col_index = col;
```

**图解说明**：

```
对于阶段t，线程需要加载B的哪个元素？
1. 行索引：平铺起始行 + 线程在y方向的位置
2. 列索引：col（固定，因为计算C[row][col]需要B的col列）

B矩阵访问模式（TILE_WIDTH=4）：
阶段t=0: 加载行 0-3
  thread ty=0 → B[0][col]
  thread ty=1 → B[1][col]
  thread ty=2 → B[2][col]
  thread ty=3 → B[3][col]

阶段t=1: 加载行 4-7
  thread ty=0 → B[4][col]
  thread ty=1 → B[5][col]
  thread ty=2 → B[6][col]
  thread ty=3 → B[7][col]

通用公式：B_row_index = t×TILE_WIDTH + ty
```

## 五、协作加载过程图解

### 5.1 一个Block的加载过程（TILE_WIDTH=4）

```
阶段t=0：
线程分布与加载任务：
┌─────────┬─────────┐
│ 线程    │ 加载任务│
├─────────┼─────────┤
│ (ty=0,tx=0)│ A[row][0], B[0][col] │
│ (ty=0,tx=1)│ A[row][1], B[0][col] │ ← 问题：多个线程加载相同B元素！
│ (ty=0,tx=2)│ A[row][2], B[0][col] │
│ (ty=0,tx=3)│ A[row][3], B[0][col] │
│ (ty=1,tx=0)│ A[row][0], B[1][col] │
│ ...     │ ...     │
└─────────┴─────────┘

问题：上面代码中的B加载方式有问题！
```

## 六、纠正的索引计算

正确的B索引应该是：

```cpp
// 正确的B矩阵索引计算：
int B_row_index = t * TILE_WIDTH + ty;  // 这个正确
int B_col_index = col;                  // 这个正确

// 但是加载到共享内存的方式需要调整：
// 每个线程应该只加载一个元素到sharedA和一个元素到sharedB
// 但上面的伪代码中，对于B，所有tx相同的线程加载的是同一个B元素

// 正确的协作加载模式：
sharedA[ty][tx] = A[row * N + (t * TILE_WIDTH + tx)];
sharedB[ty][tx] = B[(t * TILE_WIDTH + ty) * N + col];
// 注意：这样写所有线程的tx都参与，但ty也参与B的加载
```

### 6.1 正确的协作加载图解

```
共享内存分配：
sharedA[TILE_WIDTH][TILE_WIDTH] - 存储A的一个平铺
sharedB[TILE_WIDTH][TILE_WIDTH] - 存储B的一个平铺

阶段t=0的加载任务：
┌─────────────────────────────────────────────┐
│ 矩阵A平铺加载（行方向展开）                  │
│ 线程(ty,tx) 加载 A[row][tx] 到 sharedA[ty][tx]│
│ 但这里有问题：所有ty不同的线程加载相同A元素！ │
└─────────────────────────────────────────────┘

实际上，正确的协作加载应该是：
对于A平铺：需要加载 A[row][t*TILE_WIDTH + tx] 到 sharedA[ty][tx]
但是！同一列的不同ty线程会加载相同的A元素，这不对。

应该修改为：sharedA[ty][tx] = A[(by*TILE_WIDTH+ty) * N + (t*TILE_WIDTH+tx)]
```

## 七、完全正确的索引方案

### 7.1 标准平铺矩阵乘法索引

```cpp
// 正确的索引计算（常用模式）：
__global__ void matrixMulShared(float* A, float* B, float* C, int N) {
    __shared__ float sharedA[TILE_WIDTH][TILE_WIDTH];
    __shared__ float sharedB[TILE_WIDTH][TILE_WIDTH];

    int bx = blockIdx.x;
    int by = blockIdx.y;
    int tx = threadIdx.x;
    int ty = threadIdx.y;

    // 计算当前线程处理的C元素位置
    int row = by * TILE_WIDTH + ty;
    int col = bx * TILE_WIDTH + tx;

    float Cvalue = 0;

    // 循环所有平铺
    for (int t = 0; t < N/TILE_WIDTH; ++t) {
        // 协作加载A的平铺
        // 每个线程加载A的一个元素
        // A平铺的位置：第by行，第t列
        sharedA[ty][tx] = A[(by * TILE_WIDTH + ty) * N + (t * TILE_WIDTH + tx)];

        // 协作加载B的平铺
        // 每个线程加载B的一个元素
        // B平铺的位置：第t行，第bx列
        sharedB[ty][tx] = B[(t * TILE_WIDTH + ty) * N + (bx * TILE_WIDTH + tx)];

        __syncthreads();

        // 计算部分和
        for (int k = 0; k < TILE_WIDTH; ++k) {
            Cvalue += sharedA[ty][k] * sharedB[k][tx];
        }

        __syncthreads();
    }

    // 写入结果
    if (row < N && col < N) {
        C[row * N + col] = Cvalue;
    }
}
```

### 7.2 图解正确的数据流

```
阶段t的计算：
1. 加载A平铺（位置：网格的行by，平铺列t）：
   sharedA[ty][tx] = A[行索引][列索引]
   行索引 = by*TILE_WIDTH + ty
   列索引 = t*TILE_WIDTH + tx

2. 加载B平铺（位置：平铺行t，网格的列bx）：
   sharedB[ty][tx] = B[行索引][列索引]
   行索引 = t*TILE_WIDTH + ty
   列索引 = bx*TILE_WIDTH + tx

3. 计算：Cvalue += Σ sharedA[ty][k] × sharedB[k][tx]
```

### 7.3 可视化示例（N=8, TILE_WIDTH=4）

```
网格：2×2个Blocks (N/TILE_WIDTH=2)
Block(0,0)的计算：

阶段t=0:
加载A平铺(0,0):
  sharedA加载来自A[0:3, 0:3]
加载B平铺(0,0):
  sharedB加载来自B[0:3, 0:3]

阶段t=1:
加载A平铺(0,1):
  sharedA加载来自A[0:3, 4:7]
加载B平铺(1,0):
  sharedB加载来自B[4:7, 0:3]

计算完成后，Block(0,0)得到C[0:3, 0:3]
```

## 八、总结

关键点：

1. **每个线程加载一个A元素和一个B元素**到共享内存
2. **协作加载**：所有线程共同填充sharedA和sharedB
3. **索引计算**：
   - A元素：行由block行索引和ty决定，列由平铺索引和tx决定
   - B元素：行由平铺索引和ty决定，列由block列索引和tx决定
4. **同步**：加载后需要__syncthreads()，计算后也需要

这样的设计确保了：

- 共享内存被有效利用
- 全局内存访问合并
- 计算过程中数据重用最大化
